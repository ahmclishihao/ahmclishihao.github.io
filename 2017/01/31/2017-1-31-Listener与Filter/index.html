<!DOCTYPE html><html lang="zh_CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 2017-1-31-Listener与Filter · 潜水的沙 -- Java 开发者</title><meta name="description" content="2017-1-31-Listener与Filter - 潜水的沙"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://lshao.xyz/atom.xml" title="潜水的沙 -- Java 开发者"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link"> 潜水的沙</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ahmclishihao" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://blog.csdn.net/ahmclishihao" target="_blank" class="nav-list-link">CSDN</a></li><li class="nav-list-item"><a href="/about/index.html" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">2017-1-31-Listener与Filter</h1><div class="post-info">2017年1月31日</div><div class="post-content"><a id="more"></a>
<h2 id="jsonConfig"><a href="#jsonConfig" class="headerlink" title="jsonConfig"></a>jsonConfig</h2><p>jsonConfig可以通过配置不需要的bean属性，在parse阶段过滤指定属性。</p>
<h2 id="监听器Listener"><a href="#监听器Listener" class="headerlink" title="监听器Listener"></a>监听器Listener</h2><p>实现对应的接口：</p>
<p>1、监听生命周期 （web.xml 配置listener）<br>HttpSessionListener</p>
<p>ServletContextListener</p>
<p>ServletRequestListener</p>
<p>2、监听属性添加 （web.xml 配置listener）<br>HttpSessionAttributeListener</p>
<p>ServletContextAttributeListener</p>
<p>ServletRequestAttributeListener</p>
<p>3、它是用于监听javaBean对象是否绑定到了session域，用于java bean实现接口得到通知<br>HttpSessionBindingListener</p>
<p>4、钝化和活化对象 bean实现 HttpSessionActivationListener</p>
<p>我们还需要个context.xml文件来配置钝化时存储的文件<br>在meta-inf目录下创建一个context.xml文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.session.PersistentManager"</span> <span class="attr">maxIdleSwap</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Store</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.session.FileStore"</span> <span class="attr">directory</span>=<span class="string">"存储的文件夹名"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Manager</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h2><p>Javaweb中的过滤器可以拦截所有访问web资源的请求或响应操作。</p>
<p>实现Filter后 需在web.xml中进行配置（类似servlet的配置）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">	<span class="comment">// 允许当前的request向下传递，不传递无法正常访问</span></span><br><span class="line">	chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个请求可以被多个Filter拦截，拦截的顺序是web.xml中的配置顺序，<strong>第一个filter会在最后一个filter结束后结束</strong></p>
<p>生命周期：</p>
<p>在服务器启动时 init</p>
<p>在一个请求到来时 doFilter</p>
<p>在服务器结束时 destroy</p>
<h3 id="Filter拦截的配置"><a href="#Filter拦截的配置" class="headerlink" title="Filter拦截的配置"></a>Filter拦截的配置</h3><p>拦截指定的servlet(不用再写url-pattern)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>MyFilter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>拦截一次request的转发和请求</p>
<p>filter会配置所拦截的所有方式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>MyFilter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h2><p>Java在其网络传输中使用的是iso-8859-1格式的编码。因为iso-8859-1是一种单字节只支持0-255的编码方式。</p>
<p>在JSP页面获取表单的值时会出现乱码，有两种解决方法：</p>
<p>1.post 在调用getParameter之前通过request.setCharacterEncoding设置字符编码</p>
<p>2.get 调用new String(str.getBytes(“iso8859-1”), “UTF-8”);编码后解码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java判断是否可以解码</span></span><br><span class="line">Charset.forName(<span class="string">"UTF-8"</span>).newEncoder().canEncode(req.getParameter(<span class="string">"id"</span>))</span><br></pre></td></tr></table></figure>
<p><strong>new String(str.getBytes(“iso8859-1”), “UTF-8”);该方法仅仅是在出现浏览器不以U8转换URL时才会使用到</strong></p>
<p>js中也可以将uri转换为u8格式的url</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enc</span>(<span class="params">uri</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> u = <span class="built_in">encodeURI</span>(uri);</span><br><span class="line">	alert(u);</span><br><span class="line">	location.href = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态代理-aop"><a href="#动态代理-aop" class="headerlink" title="动态代理+aop"></a>动态代理+aop</h2><p>代理机制需要两个要素：1、被代理对象 2、代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getPoxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 被代理对象</span></span><br><span class="line">	<span class="keyword">final</span> MyFilter myFilter = <span class="keyword">new</span> MyFilter();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 代理对象</span></span><br><span class="line">	<span class="keyword">return</span> Proxy.newProxyInstance(classLoader<span class="string">"被代理对象的加载器"</span>, interfaces[]“被代理对象所具有的接口对象”,invokeHandler“调用方法的处理类”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AOP 将对应的方法在调用前进行拦截，并穿插其他的信息，从而保证原调用方法不被改动<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getPoxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> MyFilter myFilter = <span class="keyword">new</span> MyFilter();</span><br><span class="line">	<span class="keyword">return</span> Proxy.newProxyInstance(MyFilter.class.getClassLoader(), MyFilter.class.getInterfaces(),</span><br><span class="line">			<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">				<span class="comment">// 返回调用方法的结构</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">					...</span><br><span class="line">					Object result = method.invoke(myFilter, args);</span><br><span class="line">					...</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/02/04/2017-2-4-Struts2入门/" class="prev">PREV</a><a href="/2017/01/20/2017-1-20-事务连接池/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2018 <a href="http://lshao.xyz">潜水的沙</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>